'''
이 문제의 핵심은?
서로 다른 자연수 n개를 더했을 때
최소값이 무엇인지를 생각해보자.
당연 1부터 n까지를 더한 수가 최소값일 것이다.

1+2 = 3 => n = 2일 때 만들 수 있는 최소값
1+2+3 = 6 => n = 3일 떄 만들 수 있는 최소값
1+2+3+4 = 10 => n = 4일 때 만들 수 있는 최소값

그럼 만약 s = 7이면 어떨까.
n = 4일 때 만들 수 있는 최소값이 10이므로,
n = 4보다 작아야 한다.
n = 3일 때 만들 수 있는 최소값이 6이므로,
n = 3이여야만 구하는 n의 최대값이 된다.

1+2+3+..를 구하는 공식은 우리가 안다.
n(n+1)/2
'''
# Sol 1
s = int(input())
for i in range(1, s+1):
    if i*(i+1)/2 > s:
        print(i-1)
        break
# 위 주석의 방법을 이용했다.

'''
조금만 더 생각해보자.
결국 우리가 구하는 n은
(1부터 n-1까지의 합) < s < (1부터 n까지의 합)
n(n-1)/2 < s < n(n+1)/2
위를 만족하는 n을 구하면 된다.

n(n-1)/2 < s를 n에 관해 풀어보자.
n(n-1) < 2s
n^2-n < 2s
4n^2-4n+1 < 8s+1
(2n-1)^2 < 8s+1
(2n+1) < sqrt(8s+1)
n < (sqrt(8s+1)-1)/2 ************* 1
이다.

s < n(n+1)/2 를 위와 비슷한 방법으로 풀면,
(sqrt(8s+1)-1)/2 < n+1 *********** 2
이렇게 나온다.

*1번 식과 *2번 식을 합쳐놓고 보면,
n < (sqrt(8s+1)-1)/2 < n+1이다.
n은 자연수니까
(sqrt(8s+1)-1)/2, 이 식은 최종적으로,
n.xxxx와 같은 형태의 n과 n+1사이의 수가 된다.
그럼, (sqrt(8s+1)-1)/2이 식을 내림시키면(int로 강제 형변환)
우리가 구하는 n값을 s를 이용한 식 하나로 바로 구할 수 있다.
'''
# Sol 2
print(int(((8*int(input())+1)**(0.5)-1)/2))
# 이게 숏코딩의 묘미이다.ㅇㅈ?ㅇㅇㅈ
# math라이브러리를 가져와서 sqrt()함수를 사용해도 되지만, 4**(0.5)와 같이
# 제곱 기호(**)와 0.5를 이용해서 제곱근을 구할 수 있다
